// Main App State
const state = {
    providers: [],
    selectedProvider: null,
    currentView: 'home',
    currentMeta: null,
    currentStreams: [],
    searchQuery: '',
    currentPage: 1,
};

// API Base URL
const API_BASE = window.location.origin;

// Utility Functions
function showLoading(show = true) {
    document.getElementById('loading').style.display = show ? 'block' : 'none';
}

function showError(message) {
    const errorEl = document.getElementById('errorMessage');
    errorEl.textContent = message;
    errorEl.style.display = 'block';
    setTimeout(() => {
        errorEl.style.display = 'none';
    }, 5000);
}

function hideAllViews() {
    document.querySelectorAll('.view').forEach(view => {
        view.style.display = 'none';
    });
}

function showView(viewName) {
    hideAllViews();
    const viewMap = {
        home: 'homeView',
        search: 'searchView',
        details: 'detailsView',
        player: 'playerView',
    };
    document.getElementById(viewMap[viewName]).style.display = 'block';
    state.currentView = viewName;
}

// API Calls
async function fetchProviders() {
    console.log('üì° Fetching providers from:', `${API_BASE}/api/providers`);
    try {
        const response = await fetch(`${API_BASE}/api/providers`);
        console.log('üì° Provider response status:', response.status);
        if (!response.ok) throw new Error('Failed to fetch providers');
        const providers = await response.json();
        console.log('‚úÖ Providers loaded:', providers.length, 'providers');
        console.log('üìã Provider list:', providers.map(p => p.value));
        state.providers = providers;
        return providers;
    } catch (error) {
        console.error('‚ùå Error fetching providers:', error);
        showError('Failed to load providers. Make sure the server is running and built.');
        return [];
    }
}

async function fetchCatalog(provider) {
    const response = await fetch(`${API_BASE}/api/${provider}/catalog`);
    if (!response.ok) throw new Error('Failed to fetch catalog');
    return response.json();
}

async function fetchPosts(provider, filter = '', page = 1) {
    const response = await fetch(`${API_BASE}/api/${provider}/posts?filter=${encodeURIComponent(filter)}&page=${page}`);
    if (!response.ok) throw new Error('Failed to fetch posts');
    return response.json();
}

async function searchPosts(provider, query, page = 1) {
    const response = await fetch(`${API_BASE}/api/${provider}/search?query=${encodeURIComponent(query)}&page=${page}`);
    if (!response.ok) throw new Error('Failed to search posts');
    return response.json();
}

async function fetchMeta(provider, link) {
    const response = await fetch(`${API_BASE}/api/${provider}/meta?link=${encodeURIComponent(link)}`);
    if (!response.ok) throw new Error('Failed to fetch metadata');
    return response.json();
}

async function fetchEpisodes(provider, url) {
    const response = await fetch(`${API_BASE}/api/${provider}/episodes?url=${encodeURIComponent(url)}`);
    if (!response.ok) throw new Error('Failed to fetch episodes');
    return response.json();
}

async function fetchStream(provider, link, type = 'movie') {
    const url = `${API_BASE}/api/${provider}/stream?link=${encodeURIComponent(link)}&type=${type}`;
    console.log('üé• Fetching stream:', {provider, link, type, url});
    const response = await fetch(url);
    console.log('üé• Stream response status:', response.status);
    if (!response.ok) throw new Error('Failed to fetch stream');
    const streams = await response.json();
    console.log('‚úÖ Streams received:', streams.length, 'options');
    streams.forEach((s, i) => {
        console.log(`  Stream ${i}:`, {
            server: s.server,
            type: s.type,
            quality: s.quality,
            requiresExtraction: s.requiresExtraction,
            linkPreview: s.link.substring(0, 80) + '...'
        });
    });
    return streams;
}

// UI Rendering Functions
function renderProviderSelect(providers) {
    const select = document.getElementById('providerSelect');
    select.innerHTML = '<option value="">Select Provider...</option>';
    
    providers.forEach(provider => {
        const option = document.createElement('option');
        option.value = provider.value;
        option.textContent = `${provider.display_name} (${provider.type})`;
        select.appendChild(option);
    });
}

function renderPostCard(post, provider) {
    const card = document.createElement('div');
    card.className = 'post-card';
    card.innerHTML = `
        <img src="${post.image}" alt="${post.title}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22300%22%3E%3Crect width=%22200%22 height=%22300%22 fill=%22%23333%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 fill=%22%23666%22 text-anchor=%22middle%22 dy=%22.3em%22%3ENo Image%3C/text%3E%3C/svg%3E'" />
        <div class="post-card-content">
            <h3>${post.title}</h3>
            <span class="provider-badge">${provider}</span>
        </div>
    `;
    
    card.addEventListener('click', () => {
        loadDetails(provider, post.link);
    });
    
    return card;
}

function renderPosts(posts, containerId, provider) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (posts.length === 0) {
        container.innerHTML = '<p style="color: #b3b3b3;">No results found.</p>';
        return;
    }
    
    posts.forEach(post => {
        container.appendChild(renderPostCard(post, provider));
    });
}

function renderPagination(containerId, currentPage, hasNext) {
    const container = document.getElementById(containerId);
    container.innerHTML = `
        <button ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">Previous</button>
        <span class="page-info">Page ${currentPage}</span>
        <button ${!hasNext ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">Next</button>
    `;
}

async function renderCatalogSection(provider, catalogItem) {
    try {
        const posts = await fetchPosts(provider, catalogItem.filter, 1);
        
        if (posts.length === 0) return null;
        
        const section = document.createElement('div');
        section.className = 'catalog-section';
        section.innerHTML = `<h2>${catalogItem.title}</h2>`;
        
        const grid = document.createElement('div');
        grid.className = 'posts-grid';
        posts.slice(0, 6).forEach(post => {
            grid.appendChild(renderPostCard(post, provider));
        });
        
        section.appendChild(grid);
        return section;
    } catch (error) {
        console.error(`Error rendering section ${catalogItem.title}:`, error);
        return null;
    }
}

function renderDetails(meta, provider) {
    const container = document.getElementById('detailsContent');
    
    container.innerHTML = `
        <div class="details-content">
            <img class="details-poster" src="${meta.image}" alt="${meta.title}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22300%22 height=%22450%22%3E%3Crect width=%22300%22 height=%22450%22 fill=%22%23333%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 fill=%22%23666%22 text-anchor=%22middle%22 dy=%22.3em%22%3ENo Poster%3C/text%3E%3C/svg%3E'" />
            <div class="details-info">
                <h1>${meta.title}</h1>
                <div class="details-meta">
                    <span class="meta-item">Type: ${meta.type || 'N/A'}</span>
                    ${meta.rating ? `<span class="meta-item">‚≠ê ${meta.rating}</span>` : ''}
                    ${meta.imdbId ? `<span class="meta-item">IMDb: ${meta.imdbId}</span>` : ''}
                </div>
                <p class="details-synopsis">${meta.synopsis || 'No synopsis available.'}</p>
                ${meta.tags && meta.tags.length > 0 ? `
                    <div class="details-tags">
                        ${meta.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                    </div>
                ` : ''}
                ${meta.cast && meta.cast.length > 0 ? `
                    <div class="details-cast">
                        <h3>Cast:</h3>
                        <p style="color: #b3b3b3;">${meta.cast.join(', ')}</p>
                    </div>
                ` : ''}
                <div id="seasonSelector"></div>
            </div>
        </div>
    `;
    
    // Render seasons/episodes
    if (meta.linkList && meta.linkList.length > 0) {
        renderSeasonSelector(meta.linkList, provider, meta.type);
    }
}

function renderSeasonSelector(linkList, provider, type) {
    const container = document.getElementById('seasonSelector');
    
    container.innerHTML = `
        <div class="season-selector">
            <h3>Select Season/Quality:</h3>
            <select id="seasonSelect">
                ${linkList.map((item, index) => `
                    <option value="${index}">${item.title} ${item.quality ? `(${item.quality})` : ''}</option>
                `).join('')}
            </select>
            <div id="episodesList" class="episodes-list"></div>
        </div>
    `;
    
    const select = document.getElementById('seasonSelect');
    select.addEventListener('change', (e) => {
        const selectedIndex = e.target.value;
        renderEpisodes(linkList[selectedIndex], provider, type);
    });
    
    // Render first season by default
    renderEpisodes(linkList[0], provider, type);
}

async function renderEpisodes(linkItem, provider, type) {
    const container = document.getElementById('episodesList');
    container.innerHTML = '<p style="color: #b3b3b3;">Loading episodes...</p>';
    
    try {
        let episodes = [];
        
        // Check if we have direct links or need to fetch episodes
        if (linkItem.directLinks && linkItem.directLinks.length > 0) {
            episodes = linkItem.directLinks;
        } else if (linkItem.episodesLink) {
            episodes = await fetchEpisodes(provider, linkItem.episodesLink);
        }
        
        if (episodes.length === 0) {
            container.innerHTML = '<p style="color: #b3b3b3;">No episodes available.</p>';
            return;
        }
        
        container.innerHTML = '';
        episodes.forEach(episode => {
            const card = document.createElement('div');
            card.className = 'episode-card';
            card.innerHTML = `
                <h4>${episode.title}</h4>
                ${linkItem.quality ? `<span class="quality">${linkItem.quality}</span>` : ''}
            `;
            
            card.addEventListener('click', () => {
                loadPlayer(provider, episode.link, episode.type || type);
            });
            
            container.appendChild(card);
        });
    } catch (error) {
        console.error('Error loading episodes:', error);
        container.innerHTML = '<p style="color: #e50914;">Failed to load episodes.</p>';
    }
}

function renderStreamSelector(streams, provider) {
    console.log('üé¨ renderStreamSelector called', {streams, provider, streamCount: streams.length});
    const container = document.getElementById('streamSelector');
    
    if (streams.length === 0) {
        console.warn('‚ö†Ô∏è No streams available');
        container.innerHTML = '<p style="color: #b3b3b3;">No streams available.</p>';
        return;
    }
    
    console.log('‚úÖ Rendering', streams.length, 'stream options');
    container.innerHTML = `
        <h3>Available Streams:</h3>
        <p style="color: #b3b3b3; font-size: 14px; margin-bottom: 10px;">
            üí° If a stream doesn't play, try another one below or use the download button.
        </p>
        <div class="stream-options"></div>
    `;
    
    const optionsContainer = container.querySelector('.stream-options');
    streams.forEach((stream, index) => {
        console.log(`üì∫ Processing stream ${index}:`, {
            server: stream.server,
            link: stream.link,
            type: stream.type,
            quality: stream.quality,
            requiresExtraction: stream.requiresExtraction
        });
        
        const option = document.createElement('div');
        option.className = `stream-option ${index === 0 ? 'active' : ''}`;
        
        // Check if MKV FIRST before using the variable
        const isMKV = stream.link.toLowerCase().includes('.mkv');
        console.log(`  - Is MKV: ${isMKV}`);
        
        // Add indicators for special streams
        let indicator = '';
        if (stream.requiresExtraction) {
            indicator = '<span style="font-size: 11px; color: #ffa500;">‚ö†Ô∏è Needs extraction</span>';
            console.log('  - Marked for extraction');
        } else if (isMKV) {
            indicator = '<span style="font-size: 11px; color: #4CAF50;">‚úì Direct link</span>';
            console.log('  - Direct MKV link detected');
        }
        
        option.innerHTML = `
            <h4>${stream.server}</h4>
            ${stream.quality ? `<span class="quality">${stream.quality}p</span>` : ''}
            <span class="quality">${stream.type}</span>
            ${indicator}
            <div style="margin-top: 8px; display: flex; gap: 8px;">
                <button class="play-btn" style="padding: 5px 12px; background: #e50914; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 12px;">
                    ‚ñ∂Ô∏è Play
                </button>
                ${isMKV || stream.requiresExtraction ? `
                    <button class="download-btn" style="padding: 5px 12px; background: #333; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 12px;">
                        ‚¨áÔ∏è Download
                    </button>
                ` : ''}
            </div>
        `;
        
        const playBtn = option.querySelector('.play-btn');
        playBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.stream-option').forEach(el => el.classList.remove('active'));
            option.classList.add('active');
            playStream(stream);
        });
        
        const downloadBtn = option.querySelector('.download-btn');
        if (downloadBtn) {
            downloadBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                
                let downloadUrl = stream.link;
                
                // Only extract if needed
                if (stream.requiresExtraction) {
                    showLoading();
                    try {
                        const response = await fetch(`${API_BASE}/api/proxy/stream?url=${encodeURIComponent(stream.link)}`);
                        if (response.ok) {
                            const data = await response.json();
                            downloadUrl = data.streamUrl;
                        } else {
                            showError('Could not extract download link. The URL might already be direct.');
                        }
                    } catch (error) {
                        console.error('Extraction error:', error);
                        showError('Extraction failed. Opening original link...');
                    }
                    showLoading(false);
                }
                
                // Open download in new tab
                console.log('Opening download URL:', downloadUrl);
                window.open(downloadUrl, '_blank');
            });
        }
        
        optionsContainer.appendChild(option);
    });
}

async function playStream(stream) {
    console.log('‚ñ∂Ô∏è playStream called with:', {
        server: stream.server,
        type: stream.type,
        quality: stream.quality,
        requiresExtraction: stream.requiresExtraction,
        linkPreview: stream.link.substring(0, 100)
    });
    
    const video = document.getElementById('videoPlayer');
    console.log('üì∫ Video element:', video ? 'Found' : 'NOT FOUND');
    
    try {
        let streamUrl = stream.link;
        
        // Check if stream needs extraction
        if (stream.requiresExtraction) {
            showLoading();
            console.log(`‚ö†Ô∏è Stream requires extraction: ${stream.extractionService}`);
            
            try {
                const extractUrl = `${API_BASE}/api/proxy/stream?url=${encodeURIComponent(stream.link)}`;
                console.log('üîÑ Calling extraction endpoint:', extractUrl);
                const response = await fetch(extractUrl);
                console.log('üîÑ Extraction response status:', response.status);
                if (!response.ok) {
                    throw new Error('Failed to extract stream URL');
                }
                const data = await response.json();
                streamUrl = data.streamUrl;
                console.log('‚úÖ Extracted stream URL:', streamUrl);
            } catch (extractError) {
                console.error('‚ùå Extraction error:', extractError);
                showError(`Failed to extract stream from ${stream.extractionService}. Try downloading instead.`);
                showLoading(false);
                return;
            }
            showLoading(false);
        }
        
        console.log('üéØ Attempting to play:', streamUrl);
        
        // Check file type
        const isMKV = streamUrl.toLowerCase().includes('.mkv');
        const isMP4 = streamUrl.toLowerCase().includes('.mp4');
        const isM3U8 = stream.type === 'm3u8' || streamUrl.includes('.m3u8');
        
        console.log('üìä Stream analysis:', {isMKV, isMP4, isM3U8, streamUrl: streamUrl.substring(0, 100)});
        
        if (isMKV) {
            console.log('‚ö†Ô∏è MKV format detected - prompting user');
            // MKV files often don't play in browsers - offer download immediately
            const tryPlay = confirm('MKV format detected. This format usually doesn\'t play in browsers.\n\nClick OK to try playing anyway, or Cancel to download the file.');
            if (!tryPlay) {
                console.log('üì• User chose to download MKV');
                window.open(streamUrl, '_blank');
                return;
            }
            console.log('üé¨ User chose to try playing MKV');
        }
        
        // Clear previous content
        console.log('üßπ Clearing previous video content');
        video.innerHTML = '';
        video.src = '';
        
        // Check if HLS stream
        if (isM3U8) {
            console.log('üé¨ HLS stream detected, initializing hls.js');
            if (Hls.isSupported()) {
                console.log('‚úÖ HLS.js is supported');
                if (window.currentHls) {
                    console.log('üßπ Destroying previous HLS instance');
                    window.currentHls.destroy();
                }
                
                const hls = new Hls({
                    enableWorker: true,
                    maxBufferLength: 30,
                    maxMaxBufferLength: 600,
                });
                
                console.log('üîó Loading HLS source:', streamUrl.substring(0, 100));
                hls.loadSource(streamUrl);
                hls.attachMedia(video);
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('‚úÖ HLS manifest parsed successfully');
                    video.play().catch(e => {
                        console.error('‚ùå HLS play error:', e);
                        showError('Failed to start playback: ' + e.message);
                    });
                });
                
                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('‚ùå HLS error:', data);
                    if (data.fatal) {
                        console.error('üõë Fatal HLS error detected:', data.type);
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error('üåê Network error:', data.details);
                                showError('Network error while loading stream. Check your connection or try another source.');
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error('üé• Media error:', data.details);
                                showError('Media error. Try another quality or source.');
                                hls.recoverMediaError();
                                break;
                            default:
                                console.error('‚ùì Unknown HLS error:', data);
                                showError('Fatal playback error. Try another source.');
                                break;
                        }
                    }
                });
                
                window.currentHls = hls;
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari)
                video.src = streamUrl;
                video.addEventListener('loadedmetadata', () => {
                    video.play().catch(e => {
                        console.error('Play error:', e);
                        showError('Failed to start playback: ' + e.message);
                    });
                });
            } else {
                showError('HLS playback not supported in this browser.');
                return;
            }
        } else {
            // Direct video file
            console.log('üé¨ Direct video playback mode');
            console.log('üîó Setting video source:', streamUrl.substring(0, 100));
            video.src = streamUrl;
            
            video.addEventListener('error', (e) => {
                console.error('‚ùå Video error event:', e);
                console.error('üö® Video error object:', video.error);
                let errorMsg = 'Failed to load video.';
                
                if (video.error) {
                    console.error('üêû Error code:', video.error.code, 'Message:', video.error.message);
                    switch (video.error.code) {
                        case MediaError.MEDIA_ERR_ABORTED:
                            errorMsg = 'Video loading was aborted.';
                            console.error('‚èπÔ∏è MEDIA_ERR_ABORTED');
                            break;
                        case MediaError.MEDIA_ERR_NETWORK:
                            errorMsg = 'Network error while loading video. Check your connection.';
                            console.error('üåê MEDIA_ERR_NETWORK');
                            break;
                        case MediaError.MEDIA_ERR_DECODE:
                            errorMsg = 'Video format not supported or corrupted. Try another source.';
                            console.error('üêõ MEDIA_ERR_DECODE');
                            break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMsg = 'Video format not supported by your browser. Try another source.';
                            console.error('‚ùå MEDIA_ERR_SRC_NOT_SUPPORTED');
                            break;
                    }
                }
                
                showError(errorMsg);
            }, { once: true });
            
            console.log('‚ñ∂Ô∏è Attempting to play video...');
            video.play().catch(e => {
                console.error('‚ùå Direct play error:', e);
                console.error('Error name:', e.name, 'Message:', e.message);
                showError('Failed to start playback: ' + e.message);
            });
        }
        
        // Add subtitles if available
        if (stream.subtitles && stream.subtitles.length > 0) {
            console.log('üìë Adding', stream.subtitles.length, 'subtitle tracks');
            stream.subtitles.forEach((subtitle, index) => {
                const track = document.createElement('track');
                track.kind = 'subtitles';
                track.label = subtitle.title || subtitle.language;
                track.srclang = subtitle.language || 'en';
                track.src = subtitle.uri;
                if (index === 0) track.default = true;
                video.appendChild(track);
                console.log(`  - Subtitle ${index}:`, subtitle.language, subtitle.title);
            });
        }
    } catch (error) {
        console.error('‚ùå Stream playback error:', error);
        console.error('Error stack:', error.stack);
        showError('Failed to play stream: ' + error.message);
    }
}

// Event Handlers
async function loadHomePage() {
    const provider = state.selectedProvider;
    if (!provider) {
    
    showLoading();
    try {
        const catalogData = await fetchCatalog(provider);
        const catalogContainer = document.getElementById('catalogSections');
        catalogContainer.innerHTML = '';
        
        // Render catalog sections
        for (const item of catalogData.catalog || []) {
            const section = await renderCatalogSection(provider, item);
            if (section) catalogContainer.appendChild(section);
        }
        
        // Render genres if available
        if (catalogData.genres && catalogData.genres.length > 0) {
            const genresSection = document.createElement('div');
            genresSection.className = 'catalog-section';
            genresSection.innerHTML = '<h2>Genres</h2>';
            
            const genresGrid = document.createElement('div');
            genresGrid.style.display = 'flex';
            genresGrid.style.gap = '10px';
            genresGrid.style.flexWrap = 'wrap';
            
            catalogData.genres.forEach(genre => {
                const genreBtn = document.createElement('button');
                genreBtn.className = 'tag';
                genreBtn.textContent = genre.title;
                genreBtn.style.cursor = 'pointer';
                genreBtn.addEventListener('click', async () => {
                    showLoading();
                    try {
                        const posts = await fetchPosts(provider, genre.filter, 1);
                        document.getElementById('searchTitle').textContent = genre.title;
                        renderPosts(posts, 'searchResults', provider);
                        renderPagination('searchPagination', 1, posts.length >= 20);
                        state.currentPage = 1;
                        state.searchQuery = genre.filter;
                        showView('search');
                    } catch (error) {
                        showError('Failed to load genre content: ' + error.message);
                    } finally {
                        showLoading(false);
                    }
                });
                genresGrid.appendChild(genreBtn);
            });
            
            genresSection.appendChild(genresGrid);
            catalogContainer.appendChild(genresSection);
        }
        
        if (catalogContainer.children.length === 0) {
            catalogContainer.innerHTML = '<p style="color: #b3b3b3;">No catalog available for this provider.</p>';
        }
        
        showView('home');
    } catch (error) {
        showError('Failed to load catalog: ' + error.message);
    } finally {
        showLoading(false);
    }
}

async function performSearch() {
    const query = document.getElementById('searchInput').value.trim();
    const provider = state.selectedProvider;
    
    if (!query) {
        showError('Please enter a search query.');
        return;
    }
    
    if (!provider) {
        showError('Please select a provider first.');
        return;
    }
    
    showLoading();
    try {
        const results = await searchPosts(provider, query, 1);
        document.getElementById('searchTitle').textContent = `Search Results for "${query}"`;
        renderPosts(results, 'searchResults', provider);
        renderPagination('searchPagination', 1, results.length >= 20);
        state.searchQuery = query;
        state.currentPage = 1;
        showView('search');
    } catch (error) {
        showError('Search failed: ' + error.message);
    } finally {
        showLoading(false);
    }
}

async function changePage(newPage) {
    const provider = state.selectedProvider;
    if (!provider) return;
    
    showLoading();
    try {
        const results = await searchPosts(provider, state.searchQuery, newPage);
        renderPosts(results, 'searchResults', provider);
        renderPagination('searchPagination', newPage, results.length >= 20);
        state.currentPage = newPage;
        window.scrollTo(0, 0);
    } catch (error) {
        showError('Failed to load page: ' + error.message);
    } finally {
        showLoading(false);
    }
}

async function loadDetails(provider, link) {
    showLoading();
    try {
        const meta = await fetchMeta(provider, link);
        state.currentMeta = { meta, provider, link };
        renderDetails(meta, provider);
        showView('details');
    } catch (error) {
        showError('Failed to load details: ' + error.message);
    } finally {
        showLoading(false);
    }
}

async function loadPlayer(provider, link, type) {
    console.log('üé¨ loadPlayer called:', {provider, link, type});
    showLoading();
    try {
        console.log('‚è≥ Fetching streams...');
        const streams = await fetchStream(provider, link, type);
        state.currentStreams = streams;
        console.log('üìä State updated with', streams.length, 'streams');
        
        if (streams.length === 0) {
            console.error('‚ùå No streams available');
            showError('No streams available for this content.');
            return;
        }
        
        console.log('üé® Rendering stream selector...');
        renderStreamSelector(streams, provider);
        console.log('üñ•Ô∏è Switching to player view');
        showView('player');
        
        // Auto-play first stream
        console.log('‚ñ∂Ô∏è Auto-playing first stream:', streams[0]);
        playStream(streams[0]);
    } catch (error) {
        console.error('‚ùå loadPlayer error:', error);
        console.error('Error stack:', error.stack);
        showError('Failed to load streams: ' + error.message);
    } finally {
        showLoading(false);
    }
}

// Initialize App
async function init() {
    console.log('üé¨ Vega Providers Web Player Initialized');
    
    // Load providers
    showLoading();
    const providers = await fetchProviders();
    renderProviderSelect(providers);
    showLoading(false);
    
    if (providers.length === 0) {
        showError('No providers available. Please build the project first: npm run build');
        return;
    }
    
    // Auto-select first provider
    if (providers.length > 0) {
        state.selectedProvider = providers[0].value;
        document.getElementById('providerSelect').value = providers[0].value;
        loadHomePage();
    }
    
    // Event Listeners
    document.getElementById('providerSelect').addEventListener('change', (e) => {
        state.selectedProvider = e.target.value;
        if (e.target.value) {
            loadHomePage();
        }
    });
    
    document.getElementById('searchBtn').addEventListener('click', performSearch);
    
    document.getElementById('searchInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            performSearch();
        }
    });
    
    document.querySelector('.logo').addEventListener('click', () => {
        if (state.selectedProvider) {
            loadHomePage();
        }
    });
    
    document.getElementById('backBtn').addEventListener('click', () => {
        if (state.selectedProvider) {
            loadHomePage();
        }
    });
    
    document.getElementById('playerBackBtn').addEventListener('click', () => {
        if (state.currentMeta) {
            renderDetails(state.currentMeta.meta, state.currentMeta.provider);
            showView('details');
        }
    });
}

// Start the app when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}

// Make changePage global for pagination buttons
window.changePage = changePage;
